<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>US Tech Salary</title>

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <!-- TODO: Site sources! -->
    <style>
        p {
            margin: 50px;
        }
    </style>
</head>

<body>
    <p id="chart1">
        <script>
            const width = 960;
            const height = 620;

            const svg = d3.select('#chart1')
                .append('svg')
                .attr('width', width)
                .attr('height', height)

            // Chart title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .style("font-size", "24px")
                .style("font-family", "Raleway, sans-serif")
                .text("Tech Salaries Across the US")

            const path = d3.geoPath();
            const projection = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 300]);

            const citiesSalaries = new Map();
            const stateNameId = new Map(); // Map from state name to id
            const cityTranslationsLabel = new Map();

            const getCityStateKey = (str) => {
                let parts = str.split(',');
                return JSON.stringify({ city: parts[0].trim(), stateId: parts[1].trim() });
            };

            Promise.all([
                d3.csv('../salary_data.csv'),
                d3.csv('../city_stats.csv'),
                d3.csv('../state_id_name.csv'),
                d3.csv('../popular_cities_translations.csv')
            ]).then(([salaryData, cityData, stateNameIdData, cityTranslationsData]) => {
                // Populate city translations
                cityTranslationsData.forEach(d => {
                    const key = getCityStateKey(d.location)
                    cityTranslationsLabel.set(key, { xTranslate: +d['x translate'], yTranslate: +d['y translate'] });
                });

                // Populate state name and id
                stateNameIdData.forEach(d => {
                    stateNameId.set(d["state_id"], d["state_name"]);
                });

                // Populate citiesSalaries map
                salaryData.forEach(d => {
                    const key = getCityStateKey(d.location);
                    const salary = d.totalyearlycompensation;

                    if (citiesSalaries.has(key)) {
                        let value = citiesSalaries.get(key);
                        value.salaries.push(salary);
                        citiesSalaries.set(key, value);
                    }
                    else citiesSalaries.set(key, { salaries: [salary] });
                });

                // Filter and append additional cities metadata from other datasets
                citiesSalaries.forEach((value, city) => {
                    cityJson = JSON.parse(city)
                    const stateName = stateNameId.get(cityJson.stateId)
                    const stats = cityData.find(d => d["City"] === cityJson.city && d["State"] === stateName);
                    if (!stats) return; // If we cannot find the city stat (likely it is not a US city, then we ignore plotting such salary data)
                    const newValue = { ...value, longitude: +stats["Longitude"], latitude: +stats["Latitude"], landArea: stats["Land Area (sq mi)"] }
                    citiesSalaries.set(city, newValue)
                });

                const salaryExtent = d3.extent(salaryData, d => d["totalyearlycompensation"]);

                // Color hue scale
                let colorScale = d3
                    .scaleSequential()
                    .domain(salaryExtent)
                    .interpolator(d3.interpolateRgb("#ADD8E6", "#003366"));

                let g = svg
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(0, 50)`);

                // Create the legend
                const legendWidth = 250;
                const legendHeight = 12;
                const numSteps = 5;

                // Define the x scale using the salary extent (for positioning the legend gradient blocks)
                let x = d3.scaleLinear()
                    .domain(salaryExtent)
                    .rangeRound([600, 850]);

                // Define the salary scale (for positioning the legend gradient blocks)
                const salaryScale = d3.scaleLinear()
                    .domain(colorScale.domain())  // Use the color scale's domain
                    .range([0, legendWidth]);

                // Generate the gradient legend
                g.selectAll("rect")
                    .data(d3.range(numSteps))  // Generate an array of steps
                    .enter()
                    .append("rect")
                    .attr("height", legendHeight)
                    .attr("x", function (d) {
                        // Map each step's domain value to its x position using the x scale
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return x(domainValue);  // Use x scale to position based on the domain value
                    })
                    .attr("width", function (d) {
                        // Calculate width of each rectangle based on difference between consecutive steps
                        const domainValue0 = salaryScale.invert((d / numSteps) * legendWidth);
                        const domainValue1 = salaryScale.invert(((d + 1) / numSteps) * legendWidth);
                        return x(domainValue1) - x(domainValue0);  // Width based on scaled difference
                    })
                    .attr("fill", function (d) {
                        // Use the color scale to get the corresponding color
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return colorScale(domainValue);
                    });


                g.append("text")
                    .attr("class", "caption")
                    .attr("x", x.range()[0])
                    .attr("y", -4)
                    .attr("fill", "#000")
                    .attr("text-anchor", "start")
                    .attr("font-weight", "bold")
                    .text("Tech Salary");

                g.call(
                    d3
                        .axisBottom(x)
                        .tickSize(15)
                        .tickFormat((x, _) => `$${(x / 1e3).toFixed(1)}K`)
                        .ticks(numSteps)
                )
                    .select(".domain")
                    .remove();

                // Fetch US topojson
                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded);

                function handleUsLoaded(us) {
                    svg.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path)

                    svg.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path)

                    // Merge salaries into array
                    let salaries = []
                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);

                        // Add longitude and latitude to each salary entry
                        const newSalaries = value.salaries.map(salary => ({ salary, ...value }));
                        salaries = salaries.concat(newSalaries)
                    });
                    // Sort by salary
                    salaries.sort((a, b) => a.salary - b.salary);

                    // Plot salary points
                    salaries.forEach(salaryEntry => {
                        const { longitude, latitude, salary } = salaryEntry

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];
                        const usSqMiles = 3.8 * 10 ** 6;

                        // Generate a random angle between 0 and 2 * PI for the direction
                        const angle = Math.random() * 2 * Math.PI;

                        // Generate a distance with bias towards the center (closer to centroid)
                        const maxDrift = salaryEntry.landArea / usSqMiles * 50000;
                        const distance = Math.random() ** 2 * maxDrift; // Squared to bias toward shorter distances

                        // Calculate the drift in x and y directions using the angle
                        const driftX = Math.cos(angle) * distance;
                        const driftY = Math.sin(angle) * distance;

                        svg.append("circle")
                            .attr("class", "salary-point")
                            .attr("cx", x + driftX)
                            .attr("cy", y + driftY)
                            .attr("r", 1.5)
                            .attr("fill", colorScale(salary))
                            .attr("opacity", 0.5);
                    });

                    // Find top cities with most job salaries
                    let rankedCities = Array.from(citiesSalaries.entries());
                    rankedCities.sort((a, b) => b[1].salaries.length - a[1].salaries.length);
                    let topCities = rankedCities.slice(0, 50);
                    let topCityKeys = new Set(topCities.map(cityEntry => cityEntry[0]));

                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);
                        const { longitude, latitude } = value;

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];

                        // Add city label if in top most popular cities
                        if (topCityKeys.has(key)) {
                            let { xTranslate, yTranslate } = cityTranslationsLabel.get(key);

                            svg.append("line")
                                .attr("x1", x)
                                .attr("y1", y)
                                .attr("x2", x + xTranslate)
                                .attr("y2", y + yTranslate)
                                .attr("stroke", "black")
                                .attr("opacity", 0.4)
                                .attr("stroke-width", 1);

                            svg.append("circle")
                                .attr("cx", x + xTranslate)
                                .attr("cy", y + yTranslate)
                                .attr("r", 1.5)
                                .attr("opacity", 0.4)
                                .attr("fill", "black")

                            svg.append("text")
                                .attr("x", x + xTranslate)
                                .attr("y", y + yTranslate)
                                .attr("class", "city-label")
                                .style("font-size", "10px")
                                .style("font-family", "Lato, sans-serif")
                                .text(`${cityJson.city}, ${cityJson.stateId}`);
                        }
                    });
                }
            });
        </script>
    </p>


    <p id="chart2">
        <svg id="chart2" width="1000" height="800"></svg>
        <script>
            let svgChart2 = d3.select("svg#chart2");
            let width2 = svgChart2.attr("width");
            let height2 = svgChart2.attr("height");
            const margin = { top: 20, right: 20, bottom: 50, left: 100 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            let chartArea = svgChart2.append("g")
                .attr("id", "chartArea")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            d3.csv("../salary_data.csv").then((rawData) => {
                rawData = rawData.filter(d => {
                    const level = d.level.toUpperCase();
                    const isValidLevel = level.startsWith("L") && !isNaN(parseInt(level.slice(1))) || level.includes("SENIOR");
                    return d.company && d.company.toUpperCase() !== "N/A" && !level.includes("INTERN") && isValidLevel;
                });

                const companyMapping = {
                    "AMAZON WEB SERVICES": "AMAZON",
                    "AWS": "AMAZON",
                    "MICROSOFT CORPORATION": "MICROSOFT",
                    "MICROSOFT CORP": "MICROSOFT",
                    "GOOGLE CLOUD": "GOOGLE",
                    "ALPHABET": "GOOGLE",
                    "Â GOOGLE": "GOOGLE",
                    "FB": "META",
                    "FACEBOOK": "META",
                    "META PLATFORMS": "META",
                    "APPLE INC.": "APPLE",
                    "INTEL CORPORATION": "INTEL",
                    "IBM CORPORATION": "IBM",
                    "INTL BUSINESS MACHINES": "IBM",
                    "ORACLE CORPORATION": "ORACLE",
                    "ORACLE CORP": "ORACLE",
                    "SAP SE": "SAP",
                    "WALMART INC.": "WALMART",
                    "WALMART LABS": "WALMART",
                    "TESLA INC.": "TESLA",
                    "TESLA MOTORS": "TESLA",
                };


                // Need to preprocess the data
                rawData.forEach(
                    d => {
                        let companyName = d.company.toUpperCase();
                        if (companyMapping[companyName]) {
                            companyName = companyMapping[companyName];
                        }
                        companyName = companyName.trim();
                        d.company = companyName;
                        d.totalyearlycompensation = +d.totalyearlycompensation;
                        if (d.company === "NETFLIX") {
                            d.level_numeric = 3;
                        }
                        else if (d.level.toUpperCase().includes("SENIOR")) {
                            d.level_numeric = 3; // Assign a specific value for "Senior"
                        } else if (d.level.startsWith("L") && !isNaN(parseInt(d.level.slice(1)))) {
                            d.level_numeric = parseInt(d.level.replace("L", ""));
                        }
                        else {
                            return;
                        }
                    }
                );


                rawData = rawData.filter(d => d.level_numeric > 0 && d.totalyearlycompensation > 0);


                const companyCountData = d3.rollups(
                    rawData,
                    v => v.length,
                    d => d.company
                ).sort((a, b) => b[1] - a[1]);

                const top50Companies = companyCountData.slice(0, 50).map(d => d[0]);

                // Some companies have L3 as their entry level need to map down to a standard scale 
                // i.e. L3 -> L1, etc...
                let standardizedData = [];
                let otherData = [];

                rawData.forEach(d => {
                    if (top50Companies.includes(d.company)) {
                        standardizedData.push(d);
                    } else {
                        otherData.push(d);
                    }
                });
                const aggregatedOtherData = d3.rollups(
                    otherData,
                    v => d3.mean(v, d => d.totalyearlycompensation),
                    d => d.level_numeric).map(([level, avgCompensation]) => {
                        return {
                            company: "OTHERS",
                            level_numeric: level,
                            totalyearlycompensation: avgCompensation || 0
                        };
                    });
                standardizedData = standardizedData.concat(aggregatedOtherData);
                const companies = Array.from(new Set(standardizedData.map(d => d.company)));
                let finalData = [];
                companies.forEach(company => {
                    let companyData = standardizedData.filter(d => d.company === company && !isNaN(d.level_numeric));
                    companyData.sort((a, b) => a.level_numeric - b.level_numeric);
                    const uniqueLevels = Array.from(new Set(companyData.map(d => d.level_numeric)));
                    const levelMapping = {};
                    uniqueLevels.forEach((level, index) => {
                        if (company === "NETFLIX") {
                            levelMapping[level] = "Senior";
                        }
                        else {
                            if (index === 0) {
                                levelMapping[level] = "L1"; // Map the lowest level to L1
                            } else if (index === 1) {
                                levelMapping[level] = "L2"; // Map the second lowest to L2
                            } else {
                                levelMapping[level] = "Senior"; // Map the rest to Senior
                            }
                        }
                    }
                    );
                    companyData.forEach(d => {
                        d.standardized_level = levelMapping[d.level_numeric];
                        if (["L1", "L2", "Senior"].includes(d.standardized_level)) {
                            finalData.push(d);
                        }
                    });

                    const avgData = d3.rollups(
                        finalData,
                        v => d3.mean(v, d => d.totalyearlycompensation),
                        d => d.company,
                        d => d.standardized_level
                    ).map(([company, levels]) => {
                        const result = { company };
                        levels.forEach(([level, avgCompensation]) => {
                            if (avgCompensation > 0) {
                                result[level] = avgCompensation;
                            }
                        });
                        return result;
                    }).filter(d => Object.keys(d).length > 1);;

                });

                // Calculate the average compensation for each standardized level per company
                const avgData = d3.rollups(
                    standardizedData,
                    v => d3.mean(v, d => d.totalyearlycompensation),
                    d => d.company,
                    d => d.standardized_level
                ).map(([company, levels]) => {
                    const result = { company };
                    levels.forEach(([level, avgCompensation]) => {
                        result[level] = avgCompensation || 0; // If no data, set compensation to 0
                    });
                    return result;
                });

                const standardizedLevels = ["L1", "L2", "Senior"];
                companies.forEach(company => {
                    let companyData = avgData.find(d => d.company === company);
                    if (companyData) {
                        standardizedLevels.forEach(level => {
                            if (!companyData[level]) {
                                companyData[level] = 0; // If level is missing, set compensation to 0
                            }
                        });
                    }
                });

                // Create color scale for levels
                const colorScale = d3.scaleOrdinal()
                    .domain(standardizedLevels)
                    .range(["#1f77b4", "#ff7f0e", "#2ca02c"]); // Different colors for L1, L2, Senior

                // Define scales for x and y axes
                const xScale = d3.scaleBand()
                    .domain(avgData.map(d => d.company))
                    .range([0, chartWidth])
                    .padding(0.1);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(avgData, d => standardizedLevels.reduce((sum, level) => sum + d[level], 0))])
                    .range([chartHeight, 0]);


                const legend = svgChart2.append("g")
                    .attr("id", "legend")
                    .attr("transform", `translate(${width2 - margin.right - 50}, ${margin.top + 50})`);

                const legendData = standardizedLevels.map((level, i) => ({
                    level: level,
                    color: colorScale(level)
                }));

                legend.selectAll("rect")
                    .data(legendData)
                    .enter()
                    .append("rect")
                    .attr("x", 0)
                    .attr("y", (d, i) => i * 25)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("fill", d => d.color);

                legend.selectAll("text")
                    .data(legendData)
                    .enter()
                    .append("text")
                    .attr("x", 30)
                    .attr("y", (d, i) => i * 25 + 15)
                    .text(d => d.level)
                    .style("font-size", "14px")
                    .attr("alignment-baseline", "middle");

                chartArea.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(0, ${chartHeight})`)
                    .call(d3.axisBottom(xScale))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");


                chartArea.append("g")
                    .attr("class", "y axis")
                    .call(d3.axisLeft(yScale));

                const stackedData = d3.stack()
                    .keys(standardizedLevels)(avgData);

                chartArea.selectAll("g.stack")
                    .data(stackedData)
                    .enter()
                    .append("g")
                    .attr("fill", d => colorScale(d.key))
                    .selectAll("rect")
                    .data(d => d)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.data.company))
                    .attr("y", d => yScale(d[1]))
                    .attr("height", d => yScale(d[0]) - yScale(d[1]))
                    .attr("width", xScale.bandwidth());

                chartArea.append("text")
                    .attr("class", "x label")
                    .attr("x", chartWidth / 2)
                    .attr("y", chartHeight + 80)
                    .style("text-anchor", "middle")
                    .text("Companies");

                chartArea.append("text")
                    .attr("class", "y label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 40)
                    .attr("x", (-chartHeight / 2))
                    .style("text-anchor", "middle")
                    .text("Average Compensation (USD)");
            });
        </script>
    </p>


    <p id="chart3">
        <script>

            // TODO: Add legend, change colors, add title, maybe add important cities
            const stateMap = new Map([
                ["AL", "ALABAMA"],
                ["AK", "ALASKA"],
                ["AZ", "ARIZON"],
                ["AR", "ARKANSAS"],
                ["CA", "CALIFORNIA"],
                ["CO", "COLORADO"],
                ["CT", "CONNECTICUT"],
                ["DE", "DELAWARE"],
                ["FL", "FLORIDA"],
                ["GA", "GEORGIA"],
                ["HI", "HAWAII"],
                ["ID", "IDAHO"],
                ["IL", "ILLINOIS"],
                ["IN", "INDIANA"],
                ["IA", "IOWA"],
                ["KS", "KANSAS"],
                ["KY", "KENTUCKY"],
                ["LA", "LOUISIANA"],
                ["ME", "MAINE"],
                ["MD", "MARYLAND"],
                ["MA", "MASSACHUSETTS"],
                ["MI", "MICHIGAN"],
                ["MN", "MINNESOTA"],
                ["MS", "MISSISSIPPI"],
                ["MO", "MISSOUR"],
                ["MT", "MONTANA"],
                ["NE", "NEBRASKA"],
                ["NV", "NEVADA"],
                ["NH", "NEW HAMPSHIRE"],
                ["NJ", "NEW JERSEY"],
                ["NM", "NEW MEXICO"],
                ["NY", "NEW YORK"],
                ["NC", "NORTH CAROLINA"],
                ["ND", "NORTH DAKOTA"],
                ["OH", "OHIO"],
                ["OK", "OKLAHOMA"],
                ["OR", "OREGON"],
                ["PA", "PENNSYLVANIA"],
                ["RI", "RHODE ISLAND"],
                ["SC", "SOUTH CAROLINA"],
                ["SD", "SOUTH DAKOTA"],
                ["TN", "TENNESSEE"],
                ["TX", "TEXAS"],
                ["UT", "UTAH"],
                ["VT", "VERMONT"],
                ["VA", "VIRGINIA"],
                ["WA", "WASHINGTON"],
                ["WV", "WEST VIRGINIA"],
                ["WI", "WISCONSIN"],
                ["WY", "WYOMING"]
            ]);

            const C3width = 1160;
            const C3height = 750;

            const svg3 = d3.select('body')
                .append('svg')
                .attr('width', C3width)
                .attr('height', C3height);

            svg3.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', C3width)
                .attr('height', C3height - 120)
                .attr('fill', "#fff")
                .attr('stroke', "#000000")
                .attr('stroke-width', "10px");

            const USMap = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 300]);

            const jobCount = new Map();

            const getCityStateKey3 = (str) => {
                let parts = str.split(',');
                return [parts[0].trim(), parts[1].trim()];
            };

            Promise.all([
                d3.csv('salary_data.csv'),
                d3.csv('city_stats.csv'),
            ]).then(([salaryData, cityData]) => {

                let max = 0;

                cityMap = new Map();
                cityData.forEach(city => {
                    const cityKey = city["City"].toUpperCase() + "," + city["State"].toUpperCase();
                    cityMap.set(cityKey, city);
                });

                salaryData.forEach(d => {

                    const cityState = getCityStateKey3(d.location);
                    const city = cityMap.get(cityState[0].toUpperCase() + "," + stateMap.get(cityState[1]));
                    if (!city) return;
                    if (jobCount.has(city)) {
                        let count = jobCount.get(city);
                        count += 1;
                        if (count > max) max = count;
                        jobCount.set(city, count);
                    }

                    else jobCount.set(city, 1);

                });

                jobCount.forEach((v, k) => {

                    jobCount.set(k, Math.log(v));

                });

                console.log("done logifying,");

                const colorScale = d3.scaleSequential()
                    .domain([0, Math.log(max)])
                    .interpolator(d3.interpolateBlues);

                const sizeScale = d3.scaleLinear()
                    .domain([0, Math.log(max)])
                    .range([0, 25]);

                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded3);

                function legendCircles(number) {

                    for (let i = 1; i < number; i++) {

                        console.log(sizeScale(10 ** i));

                        svg3.append("circle")
                            .attr("cx", 1050)
                            .attr("cy", 55 + ((i - 1) * 112.5))
                            .attr("r", sizeScale(Math.log(10 ** i)))
                            .attr("fill", "#00C")
                            .attr("opacity", 1.0);

                    }

                }

                function handleUsLoaded3(us) {
                    svg3.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path);

                    svg3.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path);

                    jobCount.forEach((value, key) => {

                        longitude = key.Longitude;
                        latitude = key.Latitude;

                        if (!parseInt(longitude) || !parseInt(latitude)) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = USMap([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];

                        // Append a circle for each city
                        svg3.append("circle")
                            .attr("class", "density")
                            .attr("cx", x)
                            .attr("cy", y)
                            .attr("r", sizeScale(value))
                            .attr("fill", "#00C")
                            .attr("opacity", 0.3);

                    });

                    const axisScale = d3.scaleLog()
                        .domain([10, 10000])
                        .range([50, C3height - 350]);

                    let leftAxis = d3.axisLeft(axisScale).ticks(5);

                    svg3.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(1000,0)`)
                        .call(leftAxis);

                    legendCircles(5);

                };



            });

        </script>
    </p>

</body>

</html>