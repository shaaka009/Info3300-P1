<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- TODO: Add note of choropleth map -->
    <title>US Location vs Tech Salary</title>

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <!-- TODO: Add simple styling here -->
    <!-- TODO: Site sources! -->
    <style>
    </style>
</head>

<body>
    <p id = "chart1">
        <script>
            const width = 960;
            const height = 600;

            const svg = d3.select('body')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const path = d3.geoPath(); // TODO: Complete
            const projection = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 300]);

            const citiesSalaries = new Map();

            const getCityStateKey = (str) => {
                let parts = str.split(',');
                return JSON.stringify({ city: parts[0].trim(), state: parts[1].trim() });
            };

            // TODO: Use map from city to ([salaries], area, longitude, latitude)
            Promise.all([
                d3.csv('../salary_data.csv'),
                d3.csv('../city_stats.csv'),
            ]).then(([salaryData, cityData]) => {
                // Populate citiesSalaries map
                salaryData.forEach(d => {
                    const key = getCityStateKey(d.location);
                    const salary = d.totalyearlycompensation;

                    if (citiesSalaries.has(key)) {
                        let value = citiesSalaries.get(key);
                        value.salaries.push(salary);
                        citiesSalaries.set(key, value);
                    }
                    else citiesSalaries.set(key, { salaries: [salary] });
                });

                // Filter and append additional cities metadata from other datasets
                citiesSalaries.forEach((value, city) => {
                    cityJson = JSON.parse(city)
                    const stats = cityData.find(d => d["City"] === cityJson.city);
                    if (!stats) return; // If we cannot find the city stat (likely it is not a US city, then we ignore plotting such salary data)

                    const newValue = { ...value, longitude: +stats["Longitude"], latitude: +stats["Latitude"], landArea: stats["Land Area (sq mi)"] }
                    citiesSalaries.set(city, newValue)
                });

                const salaryExtent = d3.extent(salaryData, d => d["totalyearlycompensation"]);

                // Color hue scale
                let colorScale = d3
                    .scaleSequential()
                    .domain(salaryExtent)
                    .interpolator(d3.interpolateRgb("#ADD8E6", "#003366"));

                let g = svg
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(0, 0)`); // TODO: Change to find appropriate place for legend
                // .attr('transform', `translate(${margins.left},${margins.top})`);

                // Create the legend
                const legendWidth = 100;
                const legendHeight = 10;
                const numSteps = 20;

                // let x = d3.scaleLinear().domain([1, 50]).rangeRound([0, 2860]);

                // Define the salary scale (for positioning the gradient blocks)
                const salaryScale = d3.scaleLinear()
                    .domain(colorScale.domain())  // Use the color scale's domain
                    .range([0, legendWidth]);

                g.selectAll("rect")
                    .data(d3.range(numSteps))  // Generate an array of steps
                    .enter()
                    .append("rect")
                    .attr("height", legendHeight)
                    .attr("x", function (d) {
                        return (d / numSteps) * width;  // Map each step to its position
                    })
                    .attr("width", width / numSteps)  // Set each block's width
                    .attr("fill", function (d) {
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return colorScale(domainValue);
                    });

                /**
                g.append("text")
                    .attr("class", "caption")
                    .attr("x", x.range()[0])
                    .attr("y", 0)
                    .attr("fill", "#000")
                    .attr("text-anchor", "start")
                    .attr("font-weight", "bold")
                    .text("US Tech Salary");

                g.call(
                    d3
                        .axisBottom(x)
                        .tickSize(13)
                        .tickFormat(function (x, i) {
                            return i ? x : x + "%";
                        })
                        .tickValues(colorScale.domain())
                )
                    .select(".domain")
                    .remove();
                **/

                // TODO: Add text + point for popular cities
                // TODO: Create scales

                // Fetch US topojson
                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded);

                function handleUsLoaded(us) {
                    svg.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path);

                    svg.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path);

                    /**
                    svg.append("path")
                        .attr("class", "county-borders")
                        .attr("d", path(topojson.mesh(us, us.objects.counties, function (a, b) { return a !== b; })));
                    **/

                    // Add salary points
                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);
                        const { longitude, latitude } = value;

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];
                        const usSqMiles = 3.8 * 10 ** 6;

                        // Append a circle for each city
                        value.salaries.sort((a, b) => a - b);
                        value.salaries.forEach(salary => {
                            // Generate a random angle between 0 and 2 * PI for the direction
                            const angle = Math.random() * 2 * Math.PI;

                            // Generate a distance with bias towards the center (closer to centroid)
                            const maxDrift = value.landArea / usSqMiles * 50000;
                            const distance = Math.random() ** 2 * maxDrift; // Squared to bias toward shorter distances

                            // Calculate the drift in x and y directions using the angle
                            const driftX = Math.cos(angle) * distance;
                            const driftY = Math.sin(angle) * distance;

                            svg.append("circle")
                                .attr("class", "salary-point")
                                .attr("cx", x + driftX)
                                .attr("cy", y + driftY)
                                .attr("r", 1.5)
                                .attr("fill", colorScale(salary))
                                .attr("opacity", 0.5)
                                .text(`${cityJson.city}, ${cityJson.state}: ${value.salaries.join(", ")}`)
                        });
                    });
                }
            });
        </script>
    </p>


    <p id = "chart2">
        <svg id="chart2" width="1000" height="800"></svg>
        <script>
            let svgChart2 = d3.select("svg#chart2");
            let width2 = svgChart2.attr("width");
            let height2 = svgChart2.attr("height");
            const margin = { top: 20, right :20, bottom: 50, left:100};
            const chartWidth = width - margin.left - margin.right; 
            const chartHeight = height - margin.top - margin.bottom; 
            let chartArea = svgChart2.append("g")
                            .attr("id", "chartArea")
                            .attr("transform", `translate(${margin.left},${margin.top})`);
            
            d3.csv("../salary_data.csv").then((rawData)=> {
                rawData = rawData.filter(d => {
                const level = d.level.toUpperCase();
                const isValidLevel = level.startsWith("L") && !isNaN(parseInt(level.slice(1))) || level.includes("SENIOR");
                return d.company && d.company.toUpperCase() !== "N/A" && !level.includes("INTERN") && isValidLevel;
            });

            const companyMapping = {
            "AMAZON WEB SERVICES": "AMAZON",
            "AWS": "AMAZON",
            "MICROSOFT CORPORATION": "MICROSOFT",
            "MICROSOFT CORP": "MICROSOFT",
            "GOOGLE CLOUD": "GOOGLE",
            "ALPHABET": "GOOGLE",
            "Â GOOGLE": "GOOGLE",  
            "FB": "META",
            "FACEBOOK": "META",
            "META PLATFORMS": "META",
            "APPLE INC.": "APPLE",
            "INTEL CORPORATION": "INTEL",
            "IBM CORPORATION": "IBM",
            "INTL BUSINESS MACHINES": "IBM",
            "ORACLE CORPORATION": "ORACLE",
            "ORACLE CORP": "ORACLE",
            "SAP SE": "SAP",
            "WALMART INC.": "WALMART",
            "WALMART LABS": "WALMART",
            "TESLA INC.": "TESLA",
            "TESLA MOTORS": "TESLA",
};


                // Need to preprocess the data
                rawData.forEach(
                    d => {
                        let companyName = d.company.toUpperCase();
                        if (companyMapping[companyName]){
                            companyName = companyMapping[companyName];
                        }
                        companyName = companyName.trim(); 
                        d.company = companyName; 
                        d.totalyearlycompensation = +d.totalyearlycompensation;
                if (d.company === "NETFLIX") {
                    d.level_numeric = 3; 
                }
                else if (d.level.toUpperCase().includes("SENIOR")) {
                    d.level_numeric = 3; // Assign a specific value for "Senior"
                } else if (d.level.startsWith("L") && !isNaN(parseInt(d.level.slice(1)))) {
                    d.level_numeric = parseInt(d.level.replace("L", ""));
                }
                else{
                    return;
                }
                    }
                );

             
                rawData = rawData.filter(d => d.level_numeric > 0 && d.totalyearlycompensation > 0);


                const companyCountData = d3.rollups(
                    rawData,
                    v => v.length, 
                    d => d.company
                ).sort((a,b) => b[1] - a[1]);

                const top50Companies = companyCountData.slice(0, 50).map(d => d[0]);

                // Some companies have L3 as their entry level need to map down to a standard scale 
                // i.e. L3 -> L1, etc...
                let standardizedData = [];
                let otherData = [];

                rawData.forEach(d => {
                    if (top50Companies.includes(d.company)) {
                    standardizedData.push(d);
                } else {
                    otherData.push(d);
                }});
                const aggregatedOtherData = d3.rollups(
                otherData,
                v => d3.mean(v, d => d.totalyearlycompensation),
                d => d.level_numeric).map(([level, avgCompensation]) => {
                return {
                    company: "OTHERS",
                    level_numeric: level,
                    totalyearlycompensation: avgCompensation || 0
                };
            });
            standardizedData = standardizedData.concat(aggregatedOtherData);
            const companies = Array.from(new Set(standardizedData.map(d => d.company)));
            let finalData = [];
                companies.forEach(company =>{
                    let companyData = standardizedData.filter(d => d.company === company && !isNaN(d.level_numeric));
                    companyData.sort((a,b) => a.level_numeric - b.level_numeric);
                    const uniqueLevels = Array.from(new Set(companyData.map(d => d.level_numeric)));
                    const levelMapping = {};
                    uniqueLevels.forEach((level, index) => {
                        if (company === "NETFLIX") {
                            levelMapping[level] = "Senior";
                        }
                    else{ 
                    if (index === 0) {
                        levelMapping[level] = "L1"; // Map the lowest level to L1
                    } else if (index === 1) {
                        levelMapping[level] = "L2"; // Map the second lowest to L2
                    } else {
                        levelMapping[level] = "Senior"; // Map the rest to Senior
                    }
                }
                }
                );
                companyData.forEach(d => {
                    d.standardized_level = levelMapping[d.level_numeric];
                    if (["L1", "L2", "Senior"].includes(d.standardized_level)) {
                        finalData.push(d);
                    }
                });

                const avgData = d3.rollups(
                finalData,
                v => d3.mean(v, d => d.totalyearlycompensation),
                d => d.company,
                d => d.standardized_level
            ).map(([company, levels]) => {
                const result = { company };
                levels.forEach(([level, avgCompensation]) => {
                    if (avgCompensation > 0){
                        result[level] = avgCompensation;
                    }
                });
                return result;
            }).filter(d => Object.keys(d).length > 1);;

            });

            // Calculate the average compensation for each standardized level per company
            const avgData = d3.rollups(
                standardizedData,
                v => d3.mean(v, d => d.totalyearlycompensation),
                d => d.company,
                d => d.standardized_level
            ).map(([company, levels]) => {
                const result = { company };
                levels.forEach(([level, avgCompensation]) => {
                    result[level] = avgCompensation || 0; // If no data, set compensation to 0
                });
                return result;
            });

            const standardizedLevels = ["L1", "L2", "Senior"];
            companies.forEach(company => {
                let companyData = avgData.find(d => d.company === company);
                if (companyData){
                standardizedLevels.forEach(level => {
                    if (!companyData[level]) {
                        companyData[level] = 0; // If level is missing, set compensation to 0
                    }
                });
            }
            });

            // Create color scale for levels
            const colorScale = d3.scaleOrdinal()
                                 .domain(standardizedLevels)
                                 .range(["#1f77b4", "#ff7f0e", "#2ca02c"]); // Different colors for L1, L2, Senior

            // Define scales for x and y axes
            const xScale = d3.scaleBand()
                             .domain(avgData.map(d => d.company))
                             .range([0, chartWidth])
                             .padding(0.1);

            const yScale = d3.scaleLinear()
                             .domain([0, d3.max(avgData, d => standardizedLevels.reduce((sum, level) => sum + d[level], 0))])
                             .range([chartHeight, 0]);
            

        const legend = svgChart2.append("g")
            .attr("id", "legend")
            .attr("transform", `translate(${width2 - margin.right - 50}, ${margin.top + 50})`);

        const legendData = standardizedLevels.map((level, i) => ({
            level: level,
            color: colorScale(level)
        }));           
        
    legend.selectAll("rect")
        .data(legendData)
        .enter()
        .append("rect")
        .attr("x", 0)
        .attr("y", (d, i) => i * 25)
        .attr("width", 20)
        .attr("height", 20)
        .attr("fill", d => d.color);

    legend.selectAll("text")
        .data(legendData)
        .enter()
        .append("text")
        .attr("x", 30)
        .attr("y", (d, i) => i * 25 + 15)
        .text(d => d.level)
        .style("font-size", "14px")
        .attr("alignment-baseline", "middle");

    chartArea.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(0, ${chartHeight})`)
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end");


    chartArea.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(yScale));

    const stackedData = d3.stack()
                            .keys(standardizedLevels)(avgData);

    chartArea.selectAll("g.stack")
                .data(stackedData)
                .enter()
                .append("g")
                .attr("fill", d => colorScale(d.key))
                .selectAll("rect")
                .data(d => d)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d.data.company))
                .attr("y", d => yScale(d[1]))
                .attr("height", d => yScale(d[0]) - yScale(d[1]))
                .attr("width", xScale.bandwidth());

    chartArea.append("text")
        .attr("class", "x label")
        .attr("x", chartWidth / 2)
        .attr("y", chartHeight + 80)
        .style("text-anchor", "middle")
        .text("Companies");

    chartArea.append("text")
        .attr("class", "y label")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 40)
        .attr("x", (-chartHeight / 2))
        .style("text-anchor", "middle")
        .text("Average Compensation (USD)");
        } 
        )


        </script>



    </p>

</body>

</html>