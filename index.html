<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>US Tech Market</title>

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <!-- TODO: Cite sources! -->
    <style>
        p {
            margin: 50px;
        }
    </style>
</head>

<body>
    <h1
        style="font-size: 36px; font-family: 'Lato', sans-serif; font-weight: 700; text-align: center; margin-top: 20px;">
        Tech Salaries across the US in different companies</h1>
    <h2 style="font-family: 'Lato', sans-serif; font-weight: bold; font-size: 28px; color: #333;">
        Chart 1: Tech Salaries Across the US</h2>
    <p style="font-family: 'Raleway', sans-serif; font-size: 18px; line-height: 1.6; color: #444; margin: 20px;">
        We wanted to see if there are dominant regions for tech jobs and whether being in a large city affects whether
        you get paid more or not. <br> <br>
        Below is a chart that shows the distribution of tech salaries across the US.
        The salaries are represented by color saturation, with darker saturations indicating higher salaries.
        The map also highlights some of the most popular cities for tech jobs. We've outlined some of the major cities
        to help
        see if it's truly dense in major cities. We can see below that California seems to be the state with the highest
        density of jobs, all in the bay area. </p>
    <p id="chart1">

        <script>
            const width = 960;
            const height = 620;

            const svg = d3.select('#chart1')
                .append('svg')
                .attr('width', width)
                .attr('height', height)

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .style("font-size", "24px")
                .style("font-family", "Raleway, sans-serif")
                .text("Tech Salaries Across the US")

            const path = d3.geoPath();
            const projection = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 300]);

            const citiesSalaries = new Map();
            const stateNameId = new Map();
            const cityTranslationsLabel = new Map();

            const getCityStateKey = (str) => {
                let parts = str.split(',');
                return JSON.stringify({ city: parts[0].trim(), stateId: parts[1].trim() });
            };

            Promise.all([
                d3.csv('../salary_data.csv'),
                d3.csv('../city_stats.csv'),
                d3.csv('../state_id_name.csv'),
                d3.csv('../popular_cities_translations.csv')
            ]).then(([salaryData, cityData, stateNameIdData, cityTranslationsData]) => {
                // Populate city translations
                cityTranslationsData.forEach(d => {
                    const key = getCityStateKey(d.location)
                    cityTranslationsLabel.set(key, { xTranslate: +d['x translate'], yTranslate: +d['y translate'] });
                });

                // Populate state name and id
                stateNameIdData.forEach(d => {
                    stateNameId.set(d["state_id"], d["state_name"]);
                });

                // Populate citiesSalaries map
                salaryData.forEach(d => {
                    const key = getCityStateKey(d.location);
                    const salary = d.totalyearlycompensation;

                    if (citiesSalaries.has(key)) {
                        let value = citiesSalaries.get(key);
                        value.salaries.push(salary);
                        citiesSalaries.set(key, value);
                    }
                    else citiesSalaries.set(key, { salaries: [salary] });
                });

                // Filter and append additional cities metadata from other datasets
                citiesSalaries.forEach((value, city) => {
                    cityJson = JSON.parse(city)
                    const stateName = stateNameId.get(cityJson.stateId)
                    const stats = cityData.find(d => d["City"] === cityJson.city && d["State"] === stateName);
                    if (!stats) return; // If we cannot find the city stat (likely it is not a US city, then we ignore plotting such salary data)
                    const newValue = { ...value, longitude: +stats["Longitude"], latitude: +stats["Latitude"], landArea: stats["Land Area (sq mi)"] }
                    citiesSalaries.set(city, newValue)
                });

                const salaryExtent = d3.extent(salaryData, d => d["totalyearlycompensation"]);

                // Color hue scale
                let colorScale = d3
                    .scaleSequential()
                    .domain(salaryExtent)
                    .interpolator(d3.interpolateRgb("#ADD8E6", "#003366"));

                let g = svg
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(0, 50)`);

                // Create the legend
                const legendWidth = 250;
                const legendHeight = 12;
                const numSteps = 5;

                // Define the x scale using the salary extent (for positioning the legend gradient blocks)
                let x = d3.scaleLinear()
                    .domain(salaryExtent)
                    .rangeRound([600, 850]);

                // Define the salary scale (for positioning the legend gradient blocks)
                const salaryScale = d3.scaleLinear()
                    .domain(colorScale.domain())  // Use the color scale's domain
                    .range([0, legendWidth]);

                // Generate the gradient legend
                g.selectAll("rect")
                    .data(d3.range(numSteps))
                    .enter()
                    .append("rect")
                    .attr("height", legendHeight)
                    .attr("x", function (d) {
                        // Map each step's domain value to its x position using the x scale
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return x(domainValue);
                    })
                    .attr("width", function (d) {
                        const domainValue0 = salaryScale.invert((d / numSteps) * legendWidth);
                        const domainValue1 = salaryScale.invert(((d + 1) / numSteps) * legendWidth);
                        return x(domainValue1) - x(domainValue0);
                    })
                    .attr("fill", function (d) {
                        // Use the color scale to get the corresponding color
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return colorScale(domainValue);
                    });


                g.append("text")
                    .attr("class", "caption")
                    .attr("x", x.range()[0])
                    .attr("y", -4)
                    .attr("fill", "#000")
                    .attr("text-anchor", "start")
                    .attr("font-weight", "bold")
                    .text("Tech Salary");

                g.call(
                    d3
                        .axisBottom(x)
                        .tickSize(15)
                        .tickFormat((x, _) => `$${(x / 1e3).toFixed(1)}K`)
                        .ticks(numSteps)
                )
                    .select(".domain")
                    .remove();

                // Fetch US topojson
                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded);

                function handleUsLoaded(us) {
                    svg.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path)

                    svg.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path)

                    // Merge salaries into array
                    let salaries = []
                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);

                        // Add longitude and latitude to each salary entry
                        const newSalaries = value.salaries.map(salary => ({ salary, ...value }));
                        salaries = salaries.concat(newSalaries)
                    });
                    // Sort by salary
                    salaries.sort((a, b) => a.salary - b.salary);

                    // Plot salary points
                    salaries.forEach(salaryEntry => {
                        const { longitude, latitude, salary } = salaryEntry

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];
                        const usSqMiles = 3.8 * 10 ** 6;

                        // Generate a random angle between 0 and 2 * PI for the direction
                        const angle = Math.random() * 2 * Math.PI;

                        // Generate a distance with bias towards the center (closer to centroid)
                        const maxDrift = salaryEntry.landArea / usSqMiles * 50000;
                        const distance = Math.random() ** 2 * maxDrift; // Squared to bias toward shorter distances

                        // Calculate the drift in x and y directions using the angle
                        const driftX = Math.cos(angle) * distance;
                        const driftY = Math.sin(angle) * distance;

                        svg.append("circle")
                            .attr("class", "salary-point")
                            .attr("cx", x + driftX)
                            .attr("cy", y + driftY)
                            .attr("r", 1.5)
                            .attr("fill", colorScale(salary))
                            .attr("opacity", 0.5);
                    });

                    // Find top cities with most job salaries
                    let rankedCities = Array.from(citiesSalaries.entries());
                    rankedCities.sort((a, b) => b[1].salaries.length - a[1].salaries.length);
                    let topCities = rankedCities.slice(0, 50);
                    let topCityKeys = new Set(topCities.map(cityEntry => cityEntry[0]));

                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);
                        const { longitude, latitude } = value;

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];

                        // Add city label if in top most popular cities
                        if (topCityKeys.has(key)) {
                            let { xTranslate, yTranslate } = cityTranslationsLabel.get(key);

                            svg.append("line")
                                .attr("x1", x)
                                .attr("y1", y)
                                .attr("x2", x + xTranslate)
                                .attr("y2", y + yTranslate)
                                .attr("stroke", "black")
                                .attr("opacity", 0.4)
                                .attr("stroke-width", 1);

                            svg.append("circle")
                                .attr("cx", x + xTranslate)
                                .attr("cy", y + yTranslate)
                                .attr("r", 1.5)
                                .attr("opacity", 0.4)
                                .attr("fill", "black")

                            svg.append("text")
                                .attr("x", x + xTranslate)
                                .attr("y", y + yTranslate)
                                .attr("class", "city-label")
                                .style("font-size", "10px")
                                .style("font-family", "Lato, sans-serif")
                                .text(`${cityJson.city}, ${cityJson.stateId}`);
                        }
                    });
                }
            });
        </script>
    </p>


    <h2 style="font-family: 'Lato', sans-serif; font-weight: bold; font-size: 28px; color: #333;">
        Chart 2: Tech Salaries Across Different Companies</h2>
    <p style="font-family: 'Raleway', sans-serif; font-size: 18px; line-height: 1.6; color: #444; margin: 20px;">
        We wanted to see if there are certain companies that dominated the tech market or if it was actually quite
        diverse between different companies.
        We also wanted to see how many people were at higher levels at these companies and if their promotion pay varied
        by a lot. <br> <br>
        Below is a chart that shows the different companies, their average salaries at each level. The salaries are
        based on the y position, the company is along the x-axis and
        the different level they're at within the company is based on the color hue which can be seen in the legend.
    </p>

    <p id="chart2">
        <svg id="chart2" width="1000" height="800"></svg>
        <script>
            let svgChart2 = d3.select("svg#chart2");
            let width2 = svgChart2.attr("width");
            let height2 = svgChart2.attr("height");
            const margin = { top: 20, right: 100, bottom: 50, left: 100 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            let chartArea = svgChart2.append("g")
                .attr("id", "chartArea")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            svgChart2.append("text")
                .attr("x", width2 / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .style("font-size", "24px")
                .style("font-family", "Raleway, sans-serif")
                .text("Tech Salaries Across Companies")

            d3.csv("../salary_data.csv").then((rawData) => {
                rawData = rawData.filter(d => {
                    const level = d.level.toUpperCase();
                    const isValidLevel = level.startsWith("L") && !isNaN(parseInt(level.slice(1))) || level.includes("SENIOR");
                    return d.company && d.company.toUpperCase() !== "N/A" && !level.includes("INTERN") && isValidLevel;
                });

                const companyMapping = {
                    "AMAZON WEB SERVICES": "AMAZON",
                    "AWS": "AMAZON",
                    "MICROSOFT CORPORATION": "MICROSOFT",
                    "MICROSOFT CORP": "MICROSOFT",
                    "GOOGLE CLOUD": "GOOGLE",
                    "ALPHABET": "GOOGLE",
                    " GOOGLE": "GOOGLE",
                    "FB": "META",
                    "FACEBOOK": "META",
                    "META PLATFORMS": "META",
                    "APPLE INC.": "APPLE",
                    "INTEL CORPORATION": "INTEL",
                    "IBM CORPORATION": "IBM",
                    "INTL BUSINESS MACHINES": "IBM",
                    "ORACLE CORPORATION": "ORACLE",
                    "ORACLE CORP": "ORACLE",
                    "SAP SE": "SAP",
                    "WALMART INC.": "WALMART",
                    "WALMART LABS": "WALMART",
                    "TESLA INC.": "TESLA",
                    "TESLA MOTORS": "TESLA",
                };


                // Need to preprocess the data
                rawData.forEach(
                    d => {
                        let companyName = d.company.toUpperCase();
                        if (companyMapping[companyName]) {
                            companyName = companyMapping[companyName];
                        }
                        companyName = companyName.trim();
                        d.company = companyName;
                        d.totalyearlycompensation = +d.totalyearlycompensation;
                        if (d.company === "NETFLIX") {
                            d.level_numeric = 3;
                        }
                        else if (d.level.toUpperCase().includes("SENIOR")) {
                            //If senior assign a specific numeric vlaue
                            d.level_numeric = 3;
                        } else if (d.level.startsWith("L") && !isNaN(parseInt(d.level.slice(1)))) {
                            d.level_numeric = parseInt(d.level.replace("L", ""));
                        }
                        else {
                            return;
                        }
                    }
                );


                rawData = rawData.filter(d => d.level_numeric > 0 && d.totalyearlycompensation > 0);


                const companyCountData = d3.rollups(
                    rawData,
                    v => v.length,
                    d => d.company
                ).sort((a, b) => b[1] - a[1]);

                const top50Companies = companyCountData.slice(0, 50).map(d => d[0]);

                // Some companies have L3 as their entry level need to map down to a standard scale 
                // i.e. L3 -> L1, etc...
                let standardizedData = [];
                let otherData = [];

                rawData.forEach(d => {
                    if (top50Companies.includes(d.company)) {
                        standardizedData.push(d);
                    } else {
                        otherData.push(d);
                    }
                });
                const aggregatedOtherData = d3.rollups(
                    otherData,
                    v => d3.median(v, d => d.totalyearlycompensation),
                    d => d.level_numeric).map(([level, avgCompensation]) => {
                        return {
                            company: "OTHERS",
                            level_numeric: level,
                            totalyearlycompensation: avgCompensation || 0
                        };
                    });
                standardizedData = standardizedData.concat(aggregatedOtherData);
                const companies = Array.from(new Set(standardizedData.map(d => d.company)));
                let finalData = [];
                companies.forEach(company => {
                    let companyData = standardizedData.filter(d => d.company === company && !isNaN(d.level_numeric));
                    companyData.sort((a, b) => a.level_numeric - b.level_numeric);
                    const uniqueLevels = Array.from(new Set(companyData.map(d => d.level_numeric)));
                    const levelMapping = {};
                    uniqueLevels.forEach((level, index) => {
                        if (company === "NETFLIX") {
                            levelMapping[level] = "Senior";
                        }
                        else {
                            if (index === 0) {
                                // Lowest is L1 
                                levelMapping[level] = "L1";
                            } else if (index === 1) {
                                // Medium is L2
                                levelMapping[level] = "L2";
                            } else {
                                // Highest is L3 i.e. senior
                                levelMapping[level] = "Senior";
                            }
                        }
                    }
                    );
                    companyData.forEach(d => {
                        d.standardized_level = levelMapping[d.level_numeric];
                        if (["L1", "L2", "Senior"].includes(d.standardized_level)) {
                            finalData.push(d);
                        }
                    });

                    const avgData = d3.rollups(
                        finalData,
                        v => d3.median(v, d => d.totalyearlycompensation),
                        d => d.company,
                        d => d.standardized_level
                    ).map(([company, levels]) => {
                        const result = { company };
                        levels.forEach(([level, avgCompensation]) => {
                            if (avgCompensation > 0) {
                                result[level] = avgCompensation;
                            }
                        });
                        return result;
                    }).filter(d => Object.keys(d).length > 1);;

                });

                // Calculate the average compensation for each standardized level per company
                const avgData = d3.rollups(
                    standardizedData,
                    v => d3.median(v, d => d.totalyearlycompensation),
                    d => d.company,
                    d => d.standardized_level
                ).map(([company, levels]) => {
                    const result = { company };
                    levels.forEach(([level, avgCompensation]) => {
                        //if data is not there, set it to 0
                        result[level] = avgCompensation || 0;
                    });
                    return result;
                });

                const standardizedLevels = ["L1", "L2", "Senior"];
                companies.forEach(company => {
                    let companyData = avgData.find(d => d.company === company);
                    if (companyData) {
                        standardizedLevels.forEach(level => {
                            if (!companyData[level]) {
                                // similarly no level just set comp to 0
                                companyData[level] = 0;
                            }
                        });
                    }
                });

                // Create color scale for levels
                const colorScale = d3.scaleOrdinal()
                    .domain(standardizedLevels)
                    // Different colors for L1, L2, Senior
                    .range(["#4e79a7", "#f28e2b", "#d62728"]);

                // Define scales for x and y axes
                const xScale = d3.scaleBand()
                    .domain(avgData
                        .sort((a, b) => (a["Senior"] || 0) + (a["L1"] || 0) + (a["L2"] || 0) - (b["Senior"] || 0) - (b["L1"] || 0) - (b["L2"] || 0))
                        .map(d => d.company))
                    .range([0, chartWidth])
                    .padding(0.1);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(avgData, d => standardizedLevels.reduce((sum, level) => sum + d[level], 0))])
                    .range([chartHeight, 0]);


                const legend = svgChart2.append("g")
                    .attr("id", "legend")
                    .attr("transform", `translate(${width2 - margin.right}, ${margin.top + 50})`);

                const legendData = standardizedLevels.map((level, i) => ({
                    level: level,
                    color: colorScale(level)
                }));

                legend.selectAll("rect")
                    .data(legendData)
                    .enter()
                    .append("rect")
                    .attr("x", 0)
                    .attr("y", (d, i) => i * 25)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("fill", d => d.color);

                legend.selectAll("text")
                    .data(legendData)
                    .enter()
                    .append("text")
                    .attr("x", 30)
                    .attr("y", (d, i) => i * 25 + 15)
                    .text(d => d.level)
                    .style("font-size", "14px")
                    .attr("alignment-baseline", "middle");

                chartArea.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(0, ${chartHeight})`)
                    .call(d3.axisBottom(xScale))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");


                chartArea.append("g")
                    .attr("class", "y axis")
                    .call(d3.axisLeft(yScale));

                const stackedData = d3.stack()
                    .keys(standardizedLevels)(avgData);

                chartArea.selectAll("g.stack")
                    .data(stackedData)
                    .enter()
                    .append("g")
                    .attr("fill", d => colorScale(d.key))
                    .selectAll("rect")
                    .data(d => d)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.data.company))
                    .attr("y", d => yScale(d[1]))
                    .attr("height", d => yScale(d[0]) - yScale(d[1]))
                    .attr("width", xScale.bandwidth());

                chartArea.append("text")
                    .attr("class", "x label")
                    .attr("x", chartWidth / 2)
                    .attr("y", chartHeight + 80)
                    .style("text-anchor", "middle")
                    .text("Companies");

                chartArea.append("text")
                    .attr("class", "y label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 40)
                    .attr("x", (-chartHeight / 2))
                    .style("text-anchor", "middle")
                    .text("Median Compensation (USD)");
            });
        </script>
    </p>

    <h2 style="font-family: 'Lato', sans-serif; font-weight: bold; font-size: 28px; color: #333;">
        Chart 3: Tech Positions Density vs Location in US</h2>
    <p style="font-family: 'Raleway', sans-serif; font-size: 18px; line-height: 1.6; color: #444; margin: 20px;">
        We wanted to experiment with a different channel what the density of jobs looked like in the tech industry
        across the US. <br> <br>
        Below is a chart that shows the different states and the density of jobs within the state based on the size of
        the circle. The appropriate legend can be seen on the right.
    </p>

    <p id="chart3">
        <script>

            // TODO: Add legend, change colors, add title, maybe add important cities
            // TODO: Replace with state_id_name.csv data
            const stateMap = new Map([
                ["AL", "ALABAMA"],
                ["AK", "ALASKA"],
                ["AZ", "ARIZONA"],
                ["AR", "ARKANSAS"],
                ["CA", "CALIFORNIA"],
                ["CO", "COLORADO"],
                ["CT", "CONNECTICUT"],
                ["DE", "DELAWARE"],
                ["FL", "FLORIDA"],
                ["GA", "GEORGIA"],
                ["HI", "HAWAII"],
                ["ID", "IDAHO"],
                ["IL", "ILLINOIS"],
                ["IN", "INDIANA"],
                ["IA", "IOWA"],
                ["KS", "KANSAS"],
                ["KY", "KENTUCKY"],
                ["LA", "LOUISIANA"],
                ["ME", "MAINE"],
                ["MD", "MARYLAND"],
                ["MA", "MASSACHUSETTS"],
                ["MI", "MICHIGAN"],
                ["MN", "MINNESOTA"],
                ["MS", "MISSISSIPPI"],
                ["MO", "MISSOURI"],
                ["MT", "MONTANA"],
                ["NE", "NEBRASKA"],
                ["NV", "NEVADA"],
                ["NH", "NEW HAMPSHIRE"],
                ["NJ", "NEW JERSEY"],
                ["NM", "NEW MEXICO"],
                ["NY", "NEW YORK"],
                ["NC", "NORTH CAROLINA"],
                ["ND", "NORTH DAKOTA"],
                ["OH", "OHIO"],
                ["OK", "OKLAHOMA"],
                ["OR", "OREGON"],
                ["PA", "PENNSYLVANIA"],
                ["RI", "RHODE ISLAND"],
                ["SC", "SOUTH CAROLINA"],
                ["SD", "SOUTH DAKOTA"],
                ["TN", "TENNESSEE"],
                ["TX", "TEXAS"],
                ["UT", "UTAH"],
                ["VT", "VERMONT"],
                ["VA", "VIRGINIA"],
                ["WA", "WASHINGTON"],
                ["WV", "WEST VIRGINIA"],
                ["WI", "WISCONSIN"],
                ["WY", "WYOMING"]
            ]);

            const C3width = 1360;
            const C3height = 750;

            const svg3 = d3.select('body')
                .append('svg')
                .attr('width', C3width)
                .attr('height', C3height);

            // svg3.append('rect')
            //     .attr('x', 0)
            //     .attr('y', 0)
            //     .attr('width', C3width)
            //     .attr('height', C3height - 120)
            //     .attr('fill', "#fff")
            //     .attr('stroke', "#000000")
            //     .attr('stroke-width', "10px");

            const USMap = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 300]);

            const jobCount = new Map();

            const getCityStateKey3 = (str) => {
                let parts = str.split(',');
                return [parts[0].trim(), parts[1].trim()];
            };

            Promise.all([
                d3.csv('salary_data.csv'),
                d3.csv('city_stats.csv'),
            ]).then(([salaryData, cityData]) => {

                let max = 0;

                cityMap = new Map();
                cityData.forEach(city => {
                    const cityKey = city["City"].toUpperCase() + "," + city["State"].toUpperCase();
                    cityMap.set(cityKey, city);
                });

                salaryData.forEach(d => {

                    const cityState = getCityStateKey3(d.location);
                    const city = cityMap.get(cityState[0].toUpperCase() + "," + stateMap.get(cityState[1]));
                    if (!city) return;
                    if (jobCount.has(city)) {
                        let count = jobCount.get(city);
                        count += 1;
                        if (count > max) max = count;
                        jobCount.set(city, count);
                    }

                    else jobCount.set(city, 1);

                });

                jobCount.forEach((v, k) => {

                    jobCount.set(k, Math.log(v));

                });

                const colorScale = d3.scaleSequential()
                    .domain([0, Math.log(max)])
                    .interpolator(d3.interpolateBlues);

                const sizeScale = d3.scaleLinear()
                    .domain([0, Math.log(max)])
                    .range([0, 25]);

                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded3);

                function legendCircles(number) {

                    for (let i = 1; i < number; i++) {
                        svg3.append("circle")
                            .attr("cx", 1120)
                            .attr("cy", 55 + ((i - 1) * 112.5))
                            .attr("r", sizeScale(Math.log(10 ** i)))
                            .attr("fill", "#00C")
                            .attr("opacity", 1.0)

                    }

                }

                function handleUsLoaded3(us) {
                    svg3.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path);

                    svg3.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path);

                    jobCount.forEach((value, key) => {

                        longitude = key.Longitude;
                        latitude = key.Latitude;

                        if (!parseInt(longitude) || !parseInt(latitude)) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = USMap([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];

                        // Append a circle for each city
                        svg3.append("circle")
                            .attr("class", "density")
                            .attr("cx", x)
                            .attr("cy", y)
                            .attr("r", sizeScale(value))
                            .attr("fill", "#00C")
                            .attr("opacity", 1)
                    });

                    const axisScale = d3.scaleLog()
                        .domain([10, 10000])
                        .range([50, C3height - 350]);

                    let leftAxis = d3.axisLeft(axisScale).ticks(5);

                    svg3.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(1070,0)`)
                        .call(leftAxis);

                    legendCircles(5);

                };

                svg3.append("text")
                    .text("SWE Job Density Across the US")
                    .attr("x", 870)
                    .attr("y", 500)
                    .attr("font-family", "'Lato', sans-serif")
                    .attr("font-size", 28)
                    .attr("color", "#333");

                svg3.append("text")
                    .text("# of Jobs in City")
                    .attr("transform", "translate(1030,280)rotate(-90)")
                    .attr("font-family", "'Lato', sans-serif")
                    .attr("font-size", 16)
                    .attr("color", "#333");
            });

        </script>
    </p>

    <h2 style="font-family: 'Lato', sans-serif; font-weight: bold; font-size: 28px; color: #333;">
        Chart 4: Compensation vs Position Level and Salary</h2>
    <p style="font-family: 'Raleway', sans-serif; font-size: 18px; line-height: 1.6; color: #444; margin: 20px;">
        We wanted to attempt to use different marks to help visualize our data even better and modify the way we
        visualize our data.
        We wanted to see if companies all converged to the same y for salary or if the range differed by a lot. We also
        wanted to
        explore what salaries looked like much more relative (on a common scale) at each level. <br> <br>
        Below is a chart representing compensation vs position at different companies that are differentiated by the
        color hues which
        can be seen on the legend on the right. </p>
    <p id="chart4">
        <svg id="chart4" width="1000" height="800"></svg>
        <script>
            let svgChart4 = d3.select("svg#chart4");
            let width4 = svgChart4.attr("width");
            let height4 = svgChart4.attr("height");
            const margin4 = { top: 20, right: 200, bottom: 50, left: 100 };
            const chartWidth4 = width4 - margin4.left - margin4.right;
            const chartHeight4 = height4 - margin4.top - margin4.bottom;
            let chartArea4 = svgChart4.append("g")
                .attr("id", "chartArea4")
                .attr("transform", `translate(${margin4.left},${margin4.top})`);

            // Define the set of companies to display
            const filteredCompanies = ["Meta/Facebook", "Google", "Netflix", "Amazon", "Apple", "Stripe", "Databricks", "Microsoft", "Figma", "OpenAI", "Nvidia", "Uber"];

            // Process the CSV data
            d3.csv("../salary_data.csv").then((rawData) => {
                // Filter data for top companies and relevant levels
                rawData = rawData.filter(d => {
                    const level = d.level.toUpperCase();
                    const isValidLevel = level.startsWith("L") && !isNaN(parseInt(level.slice(1)));
                    return d.company && d.company.toUpperCase() !== "N/A" && !level.includes("INTERN") && isValidLevel;
                });

                // Filter out only the selected companies
                rawData = rawData.filter(d => filteredCompanies.includes(d.company));

                // Map to normalized company names (if needed)
                const companyMapping = {
                    "AMAZON WEB SERVICES": "AMAZON",
                    "AWS": "AMAZON",
                    "MICROSOFT CORPORATION": "MICROSOFT",
                    "MICROSOFT CORP": "MICROSOFT",
                    "GOOGLE CLOUD": "GOOGLE",
                    "ALPHABET": "GOOGLE",
                    " GOOGLE": "GOOGLE",
                    "FB": "META",
                    "FACEBOOK": "META",
                    "META PLATFORMS": "META",
                    "APPLE INC.": "APPLE",
                    "INTEL CORPORATION": "INTEL",
                    "IBM CORPORATION": "IBM",
                    "INTL BUSINESS MACHINES": "IBM",
                    "ORACLE CORPORATION": "ORACLE",
                    "ORACLE CORP": "ORACLE",
                    "SAP SE": "SAP",
                    "WALMART INC.": "WALMART",
                    "WALMART LABS": "WALMART",
                    "TESLA INC.": "TESLA",
                    "TESLA MOTORS": "TESLA",
                };

                rawData.forEach(d => {
                    let companyName = d.company.toUpperCase();
                    if (companyMapping[companyName]) companyName = companyMapping[companyName];
                    d.company = companyName.trim();
                    d.totalyearlycompensation = +d.totalyearlycompensation;
                    if (d.level.startsWith("L") && !isNaN(parseInt(d.level.slice(1)))) d.level_numeric = parseInt(d.level.replace("L", ""));
                });

                rawData = rawData.filter(d => d.level_numeric > 0 && d.totalyearlycompensation > 0);

                // Prepare the data for the line chart
                const lineChartData = d3.rollups(
                    rawData,
                    v => d3.median(v, d => d.totalyearlycompensation),
                    d => d.company,
                    d => d.level_numeric
                ).map(([company, levels]) => {
                    const result = { company };
                    levels.forEach(([level, avgCompensation]) => {
                        if (avgCompensation > 0) result[`L${level}`] = avgCompensation;
                    });
                    return result;
                });

                // Alot of the above preprocessing was reused from chart 2.

                const companies = Array.from(new Set(lineChartData.map(d => d.company)));
                const levels = ["L1", "L2", "L3", "L4", "L5", "L6"];

                // Create scales
                const xScale = d3.scalePoint()
                    .domain(levels)
                    .range([0, chartWidth4])
                    .padding(0.5);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(lineChartData, d => Math.max(d.L1 || 0, d.L2 || 0, d.L3 || 0, d.L4 || 0, d.L5 || 0, d.L6 || 0))])
                    .range([chartHeight4, 0]);

                const colorScale = d3.scaleOrdinal()
                    .domain(companies)
                    .range(d3.schemeTableau10);

                // Define the line generator
                const lineGenerator = d3.line()
                    .x(d => xScale(d.level))
                    .y(d => yScale(d.salary));

                // Prepare data for each company
                companies.forEach(company => {
                    const companyData = levels.map(level => {
                        return {
                            level: level,
                            salary: lineChartData.find(d => d.company === company)[level] || 0
                        };
                    }).filter(d => d.salary !== 0);

                    // Draw the line for the company
                    chartArea4.append("path")
                        .datum(companyData)
                        .attr("fill", "none")
                        .attr("stroke", colorScale(company))
                        .attr("stroke-width", 2)
                        .attr("d", lineGenerator);

                    // Add circles at data points
                    chartArea4.selectAll(`circle-${company}`)
                        .data(companyData)
                        .enter()
                        .append("circle")
                        .attr("cx", d => xScale(d.level))
                        .attr("cy", d => yScale(d.salary))
                        .attr("r", 5)
                        .attr("fill", colorScale(company));
                });

                // Add axes
                chartArea4.append("g")
                    .attr("transform", `translate(0,${chartHeight4})`)
                    .call(d3.axisBottom(xScale));

                chartArea4.append("g")
                    .call(d3.axisLeft(yScale));

                // Add axes labels
                chartArea4.append("text")
                    .attr("x", chartWidth4 / 2)
                    .attr("y", chartHeight4 + 40)
                    .style("text-anchor", "middle")
                    .text("Position Level");

                chartArea4.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -50)
                    .attr("x", -chartHeight4 / 2)
                    .style("text-anchor", "middle")
                    .text("Median Total Yearly Compensation (USD)");

                // Add a legend
                const legend = svgChart4.append("g")
                    .attr("id", "legend")
                    .attr("transform", `translate(${width4 - margin4.right + 10}, ${margin4.top})`);

                companies.forEach((company, i) => {
                    const legendRow = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    // Add colored rectangles for each company
                    legendRow.append("rect")
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("fill", colorScale(company));

                    // Add text labels for each company
                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .text(company)
                        .attr("text-anchor", "start")
                        .style("alignment-baseline", "middle");
                });
            });
        </script>
    </p>

    <p style="font-family: 'Raleway', sans-serif; font-size: 18px; line-height: 1.6; color: #444; margin: 20px;">
        In conclusion, after a lot of visualizing and analyzing we can see that the tech industry is dominated in major
        cities like Seattle, (almost all of the bay area in California), New York and a few other different major
        cities.
        We can also see the pay is the highest in the bay area, which might be a way to try and counter the high tax
        rates in that region. We can see the variance between salaries is pretty high even for some of the big companies
        we know
        which is interesting as we would've thought they'd end up convering at some point, guess money isn't infinite
        even at the trillion dollar mark!
    </p>


</body>

</html>