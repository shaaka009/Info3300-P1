<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- TODO: Add note of choropleth map -->
    <title>US Location vs Tech Salary</title>

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <!-- TODO: Add simple styling here -->
    <!-- TODO: Site sources! (choropeth map video) -->
    <style>
    </style>
</head>

<body>
    <p>
        <script>
            const width = 960;
            const height = 600;
            const margins = { top: 50, right: 50, bottom: 50, left: 50 };

            const svg = d3.select('body')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('transform', `translate(${margins.left},${margins.top})`);

            // Chart title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .style("font-size", "24px")
                .style("font-family", "Raleway, sans-serif")
                .text("Tech Salaries Across the US")

            const path = d3.geoPath();
            const projection = d3
                .geoAlbersUsa()
                .scale(1280)
                .translate([480, 320]);

            const citiesSalaries = new Map();

            const getCityStateKey = (str) => {
                let parts = str.split(',');
                return JSON.stringify({ city: parts[0].trim(), state: parts[1].trim() });
            };

            // TODO: Use map from city to ([salaries], area, longitude, latitude)
            Promise.all([
                d3.csv('../salary_data.csv'),
                d3.csv('../city_stats.csv'),
            ]).then(([salaryData, cityData]) => {
                // Populate citiesSalaries map
                salaryData.forEach(d => {
                    const key = getCityStateKey(d.location);
                    const salary = d.totalyearlycompensation;

                    if (citiesSalaries.has(key)) {
                        let value = citiesSalaries.get(key);
                        value.salaries.push(salary);
                        citiesSalaries.set(key, value);
                    }
                    else citiesSalaries.set(key, { salaries: [salary] });
                });

                // Filter and append additional cities metadata from other datasets
                citiesSalaries.forEach((value, city) => {
                    cityJson = JSON.parse(city)
                    const stats = cityData.find(d => d["City"] === cityJson.city);
                    if (!stats) return; // If we cannot find the city stat (likely it is not a US city, then we ignore plotting such salary data)

                    const newValue = { ...value, longitude: +stats["Longitude"], latitude: +stats["Latitude"], landArea: stats["Land Area (sq mi)"] }
                    citiesSalaries.set(city, newValue)
                });

                const salaryExtent = d3.extent(salaryData, d => d["totalyearlycompensation"]);

                // Color hue scale
                let colorScale = d3
                    .scaleSequential()
                    .domain(salaryExtent)
                    .interpolator(d3.interpolateRgb("#ADD8E6", "#003366"));

                let g = svg
                    .append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(0, 60)`);

                // Create the legend
                const legendWidth = 250;
                const legendHeight = 12;
                const numSteps = 5;

                // Define the x scale using the salary extent (for positioning the legend gradient blocks)
                let x = d3.scaleLinear()
                    .domain(salaryExtent)
                    .rangeRound([600, 850]);

                // Define the salary scale (for positioning the legend gradient blocks)
                const salaryScale = d3.scaleLinear()
                    .domain(colorScale.domain())  // Use the color scale's domain
                    .range([0, legendWidth]);

                // Generate the gradient legend
                g.selectAll("rect")
                    .data(d3.range(numSteps))  // Generate an array of steps
                    .enter()
                    .append("rect")
                    .attr("height", legendHeight)
                    .attr("x", function (d) {
                        // Map each step's domain value to its x position using the x scale
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return x(domainValue);  // Use x scale to position based on the domain value
                    })
                    .attr("width", function (d) {
                        // Calculate width of each rectangle based on difference between consecutive steps
                        const domainValue0 = salaryScale.invert((d / numSteps) * legendWidth);
                        const domainValue1 = salaryScale.invert(((d + 1) / numSteps) * legendWidth);
                        return x(domainValue1) - x(domainValue0);  // Width based on scaled difference
                    })
                    .attr("fill", function (d) {
                        // Use the color scale to get the corresponding color
                        const domainValue = salaryScale.invert((d / numSteps) * legendWidth);
                        return colorScale(domainValue);
                    });


                g.append("text")
                    .attr("class", "caption")
                    .attr("x", x.range()[0])
                    .attr("y", -4)
                    .attr("fill", "#000")
                    .attr("text-anchor", "start")
                    .attr("font-weight", "bold")
                    .text("Tech Salary");

                g.call(
                    d3
                        .axisBottom(x)
                        .tickSize(15)
                        .tickFormat((x, _) => `$${(x / 1e3).toFixed(1)}K`)
                        .ticks(numSteps)
                )
                    .select(".domain")
                    .remove();

                // TODO: Add text + point for popular cities

                // Fetch US topojson
                d3.json("https://d3js.org/us-10m.v1.json").then(handleUsLoaded);

                function handleUsLoaded(us) {
                    svg.append("g")
                        .attr("class", "states")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.states).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "darkgray")
                        .attr("d", path)
                        .attr('transform', `translate(0, 20)`);

                    svg.append("g")
                        .attr("class", "counties")
                        .selectAll("path")
                        .data(topojson.feature(us, us.objects.counties).features)
                        .enter().append("path")
                        .attr("fill", "white")
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("opacity", 0.5)
                        .attr("d", path)
                        .attr('transform', `translate(0, 20)`);

                    // Add salary points
                    citiesSalaries.forEach((value, key) => {
                        const cityJson = JSON.parse(key);
                        const { longitude, latitude } = value;

                        if (!longitude || !latitude) return;

                        // Calculate the x, y coordinates based on the projection
                        const coords = projection([longitude, latitude]);
                        const x = coords[0];
                        const y = coords[1];
                        const usSqMiles = 3.8 * 10 ** 6;

                        // Append a circle for each city
                        value.salaries.sort((a, b) => a - b);
                        value.salaries.forEach(salary => {
                            // Generate a random angle between 0 and 2 * PI for the direction
                            const angle = Math.random() * 2 * Math.PI;

                            // Generate a distance with bias towards the center (closer to centroid)
                            const maxDrift = value.landArea / usSqMiles * 50000;
                            const distance = Math.random() ** 2 * maxDrift; // Squared to bias toward shorter distances

                            // Calculate the drift in x and y directions using the angle
                            const driftX = Math.cos(angle) * distance;
                            const driftY = Math.sin(angle) * distance;

                            svg.append("circle")
                                .attr("class", "salary-point")
                                .attr("cx", x + driftX)
                                .attr("cy", y + driftY)
                                .attr("r", 1.5)
                                .attr("fill", colorScale(salary))
                                .attr("opacity", 0.5)
                                .text(`${cityJson.city}, ${cityJson.state}: ${value.salaries.join(", ")}`)
                        });
                    });
                }
            });
        </script>
    </p>
</body>

</html>